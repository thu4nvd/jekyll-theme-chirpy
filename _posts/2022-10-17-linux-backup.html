---
layout: post
title: "\U0001F427 Linux - Backup and Recovery"
date: 2022-10-17 11:33:19.000000000 -07:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- Linux
- System
- Tools
tags: []
author: thu4nvd
permalink: "/linux-backup/"
---
<p><!-- wp:paragraph --></p>
<p>Hiện giờ với công nghệ ảo hóa thì việc backup và restore đơn giản là tạo các snapshot là xong. Ngoài ra với các doanh nghiệp lớn thì họ sử dụng các giải pháp backup lớn, như Veeam Backup, v.v...Tuy nhiên bài viết này chỉ giới thiệu các phương pháp backup và recovery cho máy chủ Linux cục bộ. Nếu muốn triển khai backup cho hàng chục linux server thì cần thêm các giải pháp automation khác kết hợp. </p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:kadence/tableofcontents {"uniqueID":"_d2d9f2-56","containerBackground":"#abb8c3","enableTitle":false} /--></p>
<p><!-- wp:paragraph --></p>
<p>Before exploring methods particular to CentOS for deploying a standard backup plan, let's first discuss typical considerations for a standard level backup policy. The first thing we want to get accustomed to is the <strong>3-2-1 backup rule</strong>.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>3-2-1 Backup Strategy</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Throughout the industry, you'll often hear the term 3-2-1 backup model. This is a very good approach to live by when implementing a backup plan. 3-2-1 is defined as follows: <br />* <strong>3 copies of data</strong>; for example, we may have the working copy; a copy put onto the CentOS server designed for redundancy using rsync; and rotated, offsite USB backups are made from data on the backup server. <br />* <strong>2 different backup mediums</strong>. We would actually have three different backup mediums in this case: the working copy on an SSD of a laptop or workstation, the CentOS server data on a RADI6 Array, and the offsite backups put on USB drives. <br />* <strong>1 copy of data offsite</strong>; we are rotating the USB drives offsite on a nightly basis. Another modern approach may be a cloud backup provider.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>System Recovery</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>A <em>bare metal restore plan</em> is simply a plan laid out by a CentOS administrator to get vital systems online with all data intact. Assuming 100% systems failure and loss of all past system hardware, an administrator must have a plan to achieve uptime with intact user-data costing minimal downtime. The monolithic kernel used in Linux actually makes bare metal restores using system images much easier than Windows. Where <strong>Windows uses a micro-kernel architecture</strong>.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>A full data restore and bare metal recovery are usually accomplished through a combination of methods including working, configured production disk-images of key operational servers, redundant backups of user data abiding by the 3-2-1 rule. Even some sensitive files that may be stored in a secure, fireproof safe with limited access to the trusted company personnel.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>A multiphase <em>bare metal restore</em> and <em>data recovery plan</em> using native CentOS tools may consist of −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list --></p>
<ul>
<li>dd to make and restore production disk-images of configured servers</li>
<li>rsync to make incremental backups of all user data</li>
<li>tar &amp; gzip to store encrypted backups of files with passwords and notes from administrators. Commonly, this can be put on a USB drive, encrypted and locked in a safe that a Senior Manager access. Also, this ensures someone else will know vital security credentials if the current administrator wins the lottery and disappears to a sunny island somewhere.</li>
</ul>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>If a system crashes due to a hardware failure or disaster, following will be the different phases of restoring operations −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list --></p>
<ul>
<li>Build a working server with a configured bare metal image</li>
<li>Restore data to the working server from backups</li>
<li>Have physical access to credentials needed to perform the first two operations</li>
</ul>
<p><!-- /wp:list --></p>
<p><!-- wp:heading --></p>
<h2>Use rsync for File Level Backups</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p><em>rsync</em> is a great utility for syncing directories of files either locally or to another server. <em>rsync</em> has been used for years by System Administrators, hence it is very refined for the purpose of backing up data. In the author's opinion, one of the best features of <em>sync</em> is its ability to be scripted from the command line.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>In this tutorial, we will discuss rsync in various ways −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list --></p>
<ul>
<li>Explore and talk about some common options</li>
<li>Create local backups</li>
<li>Create remote backups over SSH</li>
<li>Restore local backups</li>
</ul>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p><strong>rsync</strong> is named for its purpose: <em>Remote Sync</em> and is both powerful and flexible in use.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Following is a basic <em>rsync</em> remote backup over ssh −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">MiNi:~ rdc$ rsync -aAvz --progress ./Desktop/ImportantStuff/ 
rdc@192.168.1.143:home/rdc/Documents/RemoteStuff/
rdc@192.168.1.143's password:
sending incremental file list
2017-02-14 16_26_47-002 - Veeam_Architecture001.png
A Guide to the WordPress REST API | Toptal.pdf
Rick Cardon Technologies, LLC..webloc
backbox-4.5.1-i386.iso
sent 2,318,683,608 bytes  received 446 bytes  7,302,941.90 bytes/sec
total size is 2,327,091,863  speedup is 1.00
MiNi:~ rdc$
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>The following sync sent nearly 2.3GB of data across our LAN. The beauty of rsync is it works incrementally at the block level on a file-by-file basis. This means, if we change just two characters in a 1MB text file, only one or two blocks will be transferred across the lan on the next sync!</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Furthermore, the incremental function can be disabled in favor of more network bandwidth used for less CPU utilization. This might prove advisable if constantly copying several 10MB database files every 10 minutes on a 1Gb dedicated Backup-Lan. The reasoning is: these will always be changing and will be transmitting incrementally every 10 minutes and may tax load of the remote CPU. Since the total transfer load will not exceed 5 minutes, we may just wish to sync the database files in their entirety.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Following are the most common switches with <em>rsync</em> −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">rsync syntax:
rsync [options] [local path] [[remote host:remote path] or [target path
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:table --></p>
<figure class="wp-block-table">
<table>
<tbody>
<tr /></tbody>
</table>
<th>Switch</th>
<th>Action</th>
<tr>
<td>-a</td>
<td>Archive mode and assumes -r, -p, -t, -g, -l</td>
</tr>
<tr>
<td>-d</td>
<td>Sync only directory tree, no files</td>
</tr>
<tr>
<td>-r</td>
<td>Recursive into directory</td>
</tr>
<tr>
<td>-l</td>
<td>Copy symlinks as symlinks</td>
</tr>
<tr>
<td>-p</td>
<td>Preserve permissions</td>
</tr>
<tr>
<td>-g</td>
<td>Preserve group</td>
</tr>
<tr>
<td>-v</td>
<td>Verbose output</td>
</tr>
<tr>
<td>-z</td>
<td>Compress over network link</td>
</tr>
<tr>
<td>-X</td>
<td>Preserve extended attributes</td>
</tr>
<tr>
<td>-A</td>
<td>Preserve ACLs</td>
</tr>
<tr>
<td>-t</td>
<td>Preserve timestamps</td>
</tr>
<tr>
<td>-W</td>
<td>Transfer whole file, not incremental blocks</td>
</tr>
<tr>
<td>-u</td>
<td>Do not overwrite files on target</td>
</tr>
<tr>
<td>--progress</td>
<td>Show transfer progress</td>
</tr>
<tr>
<td>--delete</td>
<td>Delete older files on target</td>
</tr>
<tr>
<td>--max-size = XXX</td>
<td>Max file size to sync</td>
</tr>
</figure>
<p><!-- /wp:table --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>When to use rsync</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>My personal preference for <em>rsync</em> is when backing up files from a source host to a target host. For example, all the home directories for data recovery or even offsite and into the cloud for disaster recovery.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>Local Backup With rsync</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>We have already seen how to transfer files from one host to another. The same method can be used to sync directories and files locally.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Let's make a manual incremental backup of <em>/etc/</em> in our root user's directory.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>First, we need to create a directory off ~/root for the synced backup −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@localhost rdc]# mkdir /root/etc_baks
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Then, assure there is enough free disk-space.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@localhost rdc]# du -h --summarize /etc/ 
49M    /etc/
 
[root@localhost rdc]# df -h 
Filesystem           Size     Used     Avail    Use%     Mounted on 
/dev/mapper/cl-root   43G      15G        28G    35%         /
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>We are good for syncing our entire /etc/ directory −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">rsync -aAvr /etc/ /root/etc_baks/
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Our synced /etc/ directory −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@localhost etc_baks]# ls -l ./
total 1436
drwxr-xr-x.   3 root root      101 Feb  1 19:40 abrt
-rw-r--r--.   1 root root       16 Feb  1 19:51 adjtime
-rw-r--r--.   1 root root     1518 Jun  7  2013 aliases
-rw-r--r--.   1 root root    12288 Feb 27 19:06 aliases.db
drwxr-xr-x.   2 root root       51 Feb  1 19:41 alsa
drwxr-xr-x.   2 root root     4096 Feb 27 17:11 alternatives
-rw-------.   1 root root      541 Mar 31  2016 anacrontab
-rw-r--r--.   1 root root       55 Nov  4 12:29 asound.conf
-rw-r--r--.   1 root root        1 Nov  5 14:16 at.deny
drwxr-xr-x.   2 root root       32 Feb  1 19:40 at-spi2
--{ condensed output }--
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Now let's do an incremental rsync −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@localhost etc_baks]# rsync -aAvr --progress  /etc/ /root/etc_baks/
sending incremental file list

test_incremental.txt 
sent 204620 bytes  received 2321 bytes  413882.00 bytes/sec
total size is 80245040  speedup is 387.77

[root@localhost etc_baks]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Only our <em>test_incremental.txt</em> file was copied.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>Remote Differential Backups With rsync</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Let's do our initial rsync full backup onto a server with a backup plan deployed. This example is actually backing up a folder on a Mac OS X Workstation to a CentOS server. Another great aspect of <em>rsync</em> is that it can be used on any platform rsync has been ported to.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">MiNi:~ rdc$ rsync -aAvz Desktop/ImportanStuff/
rdc@192.168.1.143:Documents/RemoteStuff
rdc@192.168.1.143's password:
sending incremental file list
./
A Guide to the WordPress REST API | Toptal.pdf
Rick Cardon Tech LLC.webloc
VeeamDiagram.png
backbox-4.5.1-i386.iso
dhcp_admin_script_update.py
DDWRT/
DDWRT/.DS_Store
DDWRT/ddwrt-linksys-wrt1200acv2-webflash.bin
DDWRT/ddwrt_mod_notes.docx
DDWRT/factory-to-ddwrt.bin
open_ldap_config_notes/
open_ldap_config_notes/ldap_directory_a.png
open_ldap_config_notes/open_ldap_notes.txt
perl_scripts/
perl_scripts/mysnmp.pl
php_scripts/
php_scripts/chunked.php
php_scripts/gettingURL.php
sent 2,318,281,023 bytes  received 336 bytes  9,720,257.27 bytes/sec
total size is 2,326,636,892  speedup is 1.00
MiNi:~ rdc$
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>We have now backed up a folder from a workstation onto a server running a RAID6 volume with rotated disaster recovery media stored offsite. Using rsync has given us standard 3-2-1 backup with only one server having an expensive redundant disk array and rotated differential backups.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Now let's do another backup of the same folder using rsync after a single new file named <em>test_file.txt</em> has been added.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">MiNi:~ rdc$ rsync -aAvz Desktop/ImportanStuff/
rdc@192.168.1.143:Documents/RemoteStuff 
rdc@192.168.1.143's password:  
sending incremental file list 
 ./ 
test_file.txt

sent 814 bytes  received 61 bytes  134.62 bytes/sec
total size is 2,326,636,910  speedup is 2,659,013.61
MiNi:~ rdc$
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>As you can see, only the new file was delivered to the server via <em>rsync</em>. The differential comparison was made on a file-by-file basis.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>A few things to note are: This only copies the new file: test_file.txt, since it was the only file with changes. rsync uses ssh. We did not ever need to use our root account on either machine.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Simple, powerful and effective, <em>rsync</em> is great for backing up entire folders and directory structures. However, <em>rsync</em> by itself doesn't automate the process. This is where we need to dig into our toolbox and find the best, small, and simple tool for the job.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>To automate rsync backups with <em>cronjobs</em>, it is essential that SSH users be set up using SSH keys for authentication. This combined with cronjobs enables rsync to be done automatically at timed intervals.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>Use DD for Block-by-Block Bare Metal Recovery Images</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>DD is a Linux utility that has been around since the dawn of the Linux kernel meeting the GNU Utilities.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><em>dd</em> in simplest terms copies an image of a selected disk area. Then provides the ability to copy selected blocks of a physical disk. So unless you have backups, once dd writes over a disk, all blocks are replaced. Loss of previous data exceeds the recovery capabilities for even highly priced professional-level data-recovery.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>The entire process for making a bootable system image with <em>dd</em> is as follows −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:list --></p>
<ul>
<li>Boot from the CentOS server with a bootable linux distribution</li>
<li>Find the designation of the bootable disk to be imaged</li>
<li>Decide location where the recovery image will be stored</li>
<li>Find the block size used on your disk</li>
<li>Start the dd image operation</li>
</ul>
<p><!-- /wp:list --></p>
<p><!-- wp:paragraph --></p>
<p>In this tutorial, for the sake of time and simplicity, we will be creating an ISO image of the master-boot record from a CentOS virtual machine. We will then store this image offsite. In case our MBR becomes corrupted and needs to be restored, the same process can be applied to an entire bootable disk or partition. However, the time and disk space needed really goes a little overboard for this tutorial.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>It is encouraged for CentOS admins to become proficient in restoring a fully bootable disk/partition in a test environment and perform a bare metal restore. This will take a lot of pressure off when eventually one needs to complete the practice in a real life situation with Managers and a few dozen end-users counting downtime. In such a case, 10 minutes of figuring things out can seem like an eternity and make one sweat.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note</strong> − When using dd make sure to NOT confuse source and target volumes. You can destroy data and bootable servers by copying your backup location to a boot drive. Or possibly worse destroy data forever by copying over data at a very low level with DD.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Following are the common command line switches and parameters for <em>dd</em> −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:table --></p>
<figure class="wp-block-table">
<table>
<tbody>
<tr /></tbody>
</table>
<th>Switch</th>
<th>Action</th>
<tr>
<td>if=</td>
<td>In file or source to be copied</td>
</tr>
<tr>
<td>of=</td>
<td>Out file or the copy of the in file</td>
</tr>
<tr>
<td>bs</td>
<td>Set both input and output block size</td>
</tr>
<tr>
<td>obs</td>
<td>Set output file block size</td>
</tr>
<tr>
<td>ibs</td>
<td>Set input file block size</td>
</tr>
<tr>
<td>count</td>
<td>Set the number of blocks to copy</td>
</tr>
<tr>
<td>conv</td>
<td>Extra options to add for imaging</td>
</tr>
<tr>
<td>Noerror</td>
<td>Do not stop processing an error</td>
</tr>
<tr>
<td>sync</td>
<td>Pads unfitted input blocks in the event of error or misalignment</td>
</tr>
</figure>
<p><!-- /wp:table --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note on block size</strong> − The default block size for dd is 512 bytes. This was the standard block size of lower density hard disk drives. Today's higher density HDDs have increased to 4096 byte (4kB) block sizes to allow for disks ranging from 1TB and larger. Thus, we will want to check disk block size before using dd with newer, higher capacity hard disks.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>For this tutorial, instead of working on a production server with <em>dd</em>, we will be using a CentOS installation running in VMWare. We will also configure VMWare to boot a bootable Linux ISO image instead of working with a bootable USB Stick.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>First, we will need to download the CentOS image entitled: <em>CentOS Gnome ISO</em>. This is almost 3GB and it is advised to always keep a copy for creating bootable USB thumb-drives and booting into virtual server installations for trouble-shooting and bare metal images.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Other bootable Linux distros will work just as well. Linux Mint can be used for bootable ISOs as it has great hardware support and polished GUI disk tools for maintenance.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>CentOS GNOME Live bootable image can be downloaded from: <a target="_blank" rel="noreferrer noopener" href="http://buildlogs.centos.org/rolling/7/isos/x86_64/CentOS-7-x86_64-LiveGNOME.iso">http://buildlogs.centos.org/rolling/7/isos/x86_64/CentOS-7-x86_64-LiveGNOME.iso</a></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Let's configure our VMWare Workstation installation to boot from our Linux bootable image. The steps are for VMWare on OS X. However, they are similar across VMWare Workstation on Linux, Windows, and even Virtual Box.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note</strong> − Using a virtual desktop solution like Virtual Box or VMWare Workstation is a great way to set up lab scenarios for learning CentOS Administration tasks. It provides the ability to install several CentOS installations, practically no hardware configuration letting the person focus on administration, and even save the server state before making changes.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>First let's configure a virtual cd-rom and attach our ISO image to boot instead of the virtual CentOS server installation −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image --></p>
<figure class="wp-block-image"><img src="{{ site.baseurl }}/assets/2022/10/iso_image.jpg" alt="ISO image" /></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Now, set the startup disk −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:image --></p>
<figure class="wp-block-image"><img src="{{ site.baseurl }}/assets/2022/10/startup_disk.jpg" alt="Startup Disk" /></figure>
<p><!-- /wp:image --></p>
<p><!-- wp:paragraph --></p>
<p>Now when booted, our virtual machine will boot from the CentOS bootable ISO image and allow access to files on the Virtual CentOS server that was previously configured.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Let’s check our disks to see where we want to copy the MBR from (condensed output is as follows).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">MiNt ~ # fdisk -l
Disk /dev/sda: 60 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes

Disk /dev/sdb: 20 GiB, 21474836480 bytes, 41943040 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>We have located both our physical disks: <em>sda</em> and <em>sdb</em>. Each has a block size of 512 bytes. So, we will now run the <em>dd</em> command to copy the first 512 bytes for our MBR on SDA1.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>The best way to do this is −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@mint rdc]# dd if=/dev/sda bs=512 count=1  | gzip -c &gt;
/mnt/sdb/images/mbr.iso.gz 
1+0 records in 
1+0 records out 
512 bytes copied, 0.000171388 s, 3.0 MB/s

[root@mint rdc]# ls /mnt/sdb/ 
[root@mint rdc]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Just like that, we have full image of out master boot record. If we have enough room to image the boot drive, we could just as easily make a full system boot image −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">dd if=/dev/INPUT/DEVICE-NAME-HERE conv=sync,noerror bs=4K | gzip -c &gt;
/mnt/sdb/boot-server-centos-image.iso.gz
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>The <em>conv=sync</em> is used when bytes must be aligned for a physical medium. In this case, dd may get an error if exact 4K alignments are not read (say... a file that is only 3K but needs to take minimum of a single 4K block on disk. Or, there is simply an error reading and the file cannot be read by dd.). Thus, <em>dd</em> with <em>conv=sync,noerror</em> will pad the 3K with trivial, but useful data to physical medium in 4K block alignments. While not presenting an error that may end a large operation.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>When working with data from disks we always want to include: <em>conv=sync,noerror</em> parameter.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>This is simply because the disks are not streams like TCP data. They are made up of blocks aligned to a certain size. For example, if we have 512 byte blocks, a file of only 300 bytes still needs a full 512 bytes of disk-space (possibly 2 blocks for inode information like permissions and other filesystem information).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>Use gzip and tar for Secure Storage</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>gzip and tar are two utilities a CentOS administrator must become accustomed to using. They are used for a lot more than to simply decompress archives.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>Using Gnu Tar in CentOS Linux</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Tar is an archiving utility similar to <em>winrar</em> on Windows. Its name <em>Tape Archive</em> abbreviated as <em>tar</em> pretty much sums up the utility. <em>tar</em> will take files and place them into an archive for logical convenience. Hence, instead of the dozens of files stored in /etc. we could just "tar" them up into an archive for backup and storage convenience.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><em>tar</em> has been the standard for storing archived files on Unix and Linux for many years. Hence, using tar along with <em>gzip</em> or <em>bzip</em> is considered as a best practice for archives on each system.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Following is a list of common command line switches and options used with tar −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:table --></p>
<figure class="wp-block-table">
<table>
<tbody>
<tr /></tbody>
</table>
<th>Switch</th>
<th>Action</th>
<tr>
<td>-c</td>
<td>Creates a new .tar archive</td>
</tr>
<tr>
<td>-C</td>
<td>Extracts to a different directory</td>
</tr>
<tr>
<td>-j</td>
<td>Uses bzip2 compression</td>
</tr>
<tr>
<td>-z</td>
<td>Uses gzip compression</td>
</tr>
<tr>
<td>-v</td>
<td>Verbose show archiving progress</td>
</tr>
<tr>
<td>-t</td>
<td>Lists archive contents</td>
</tr>
<tr>
<td>-f</td>
<td>File name of the archive</td>
</tr>
<tr>
<td>-x</td>
<td>Extracts tar archive</td>
</tr>
</figure>
<p><!-- /wp:table --></p>
<p><!-- wp:paragraph --></p>
<p>Following is the basic syntax for creating a <em>tar</em> archive.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">tar -cvf [tar archive name]
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note on Compression mechanisms with tar</strong> − It is advised to stick with one of two common compression schemes when using tar: gzip and bzip2. gzip files consume less CPU resources but are usually larger in size. While bzip2 will take longer to compress, they utilize more CPU resources; but will result in a smaller end filesize.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>When using file compression, we will always want to use standard file extensions letting everyone including ourselves know (versus guess by trial and error) what compression scheme is needed to extract archives.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:table --></p>
<figure class="wp-block-table">
<table>
<tbody>
<tr>
<td>bzip2</td>
<td>.tbz</td>
</tr>
<tr>
<td>bzip2</td>
<td>.tar.tbz</td>
</tr>
<tr>
<td>bzip2</td>
<td>.tb2</td>
</tr>
<tr>
<td>gzip</td>
<td>.tar.gz</td>
</tr>
<tr>
<td>gzip</td>
<td>.tgz</td>
</tr>
</tbody>
</table>
</figure>
<p><!-- /wp:table --></p>
<p><!-- wp:paragraph --></p>
<p>When needing to possibly extract archives on a Windows box or for use on Windows, it is advised to use the <em>.tar.tbz</em> or <em>.tar.gz</em> as most the three character single extensions will confuse Windows and Windows only Administrators (however, that is sometimes the desired outcome)</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Let's create a <em>gzipped</em> tar archive from our remote backups copied from the Mac Workstation −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[rdc@mint Documents]$ tar -cvz -f RemoteStuff.tgz ./RemoteStuff/ 
./RemoteStuff/
./RemoteStuff/.DS_Store
./RemoteStuff/DDWRT/
./RemoteStuff/DDWRT/.DS_Store
./RemoteStuff/DDWRT/ddwrt-linksys-wrt1200acv2-webflash.bin
./RemoteStuff/DDWRT/ddwrt_mod_notes.docx
./RemoteStuff/DDWRT/factory-to-ddwrt.bin
./RemoteStuff/open_ldap_config_notes/
./RemoteStuff/open_ldap_config_notes/ldap_directory_a.png
./RemoteStuff/open_ldap_config_notes/open_ldap_notes.txt
./RemoteStuff/perl_scripts/
./RemoteStuff/perl_scripts/mysnmp.pl
./RemoteStuff/php_scripts/
./RemoteStuff/php_scripts/chunked.php
./RemoteStuff/php_scripts/gettingURL.php
./RemoteStuff/A Guide to the WordPress REST API | Toptal.pdf
./RemoteStuff/Rick Cardon Tech LLC.webloc
./RemoteStuff/VeeamDiagram.png
./RemoteStuff/backbox-4.5.1-i386.iso
./RemoteStuff/dhcp_admin_script_update.py
./RemoteStuff/test_file.txt
[rdc@mint Documents]$ ls -ld RemoteStuff.tgz
-rw-rw-r--. 1 rdc rdc 2317140451 Mar 12 06:10 RemoteStuff.tgz
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note</strong> − Instead of adding all the files directly to the archive, we archived the entire folder <em>RemoteStuff</em>. This is the easiest method. Simply because when extracted, the entire directory <em>RemoteStuff</em> is extracted with all the files inside the current working directory as <em>./currentWorkingDirectory/RemoteStuff/</em></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Now let's extract the archive inside the <em>/root/</em> home directory.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos ~]# tar -zxvf RemoteStuff.tgz
./RemoteStuff/
./RemoteStuff/.DS_Store
./RemoteStuff/DDWRT/
./RemoteStuff/DDWRT/.DS_Store
./RemoteStuff/DDWRT/ddwrt-linksys-wrt1200acv2-webflash.bin
./RemoteStuff/DDWRT/ddwrt_mod_notes.docx
./RemoteStuff/DDWRT/factory-to-ddwrt.bin
./RemoteStuff/open_ldap_config_notes/
./RemoteStuff/open_ldap_config_notes/ldap_directory_a.png
./RemoteStuff/open_ldap_config_notes/open_ldap_notes.txt
./RemoteStuff/perl_scripts/
./RemoteStuff/perl_scripts/mysnmp.pl
./RemoteStuff/php_scripts/
./RemoteStuff/php_scripts/chunked.php
./RemoteStuff/php_scripts/gettingURL.php
./RemoteStuff/A Guide to the WordPress REST API | Toptal.pdf
./RemoteStuff/Rick Cardon Tech LLC.webloc
./RemoteStuff/VeeamDiagram.png
./RemoteStuff/backbox-4.5.1-i386.iso
./RemoteStuff/dhcp_admin_script_update.py
./RemoteStuff/test_file.txt
[root@mint ~]# ping www.google.com
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>As seen above, all the files were simply extracted into the containing directory within our current working directory.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos ~]# ls -l 
total 2262872 
-rw-------.   1   root   root       1752   Feb   1   19:52   anaconda-ks.cfg 
drwxr-xr-x. 137   root   root       8192   Mar   9   04:42   etc_baks 
-rw-r--r--.   1   root   root       1800   Feb   2   03:14   initial-setup-ks.cfg 
drwxr-xr-x.   6   rdc    rdc        4096   Mar  10   22:20   RemoteStuff 
-rw-r--r--.   1   root   root 2317140451   Mar  12   07:12   RemoteStuff.tgz 
-rw-r--r--.   1   root   root       9446   Feb  25   05:09   ssl.conf [root@centos ~]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>Use gzip to Compress File Backups</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>As noted earlier, we can use either bzip2 or gzip from tar with the <strong>-j</strong> or <strong>-z</strong> command line switches. We can also use gzip to compress individual files. However, using bzip or gzip alone does not offer as many features as when combined with <em>tar</em>.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>When using <em>gzip</em>, the default action is to remove the original files, replacing each with a compressed version adding the .gz extension.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Some common command line switches for gzip are −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:table --></p>
<figure class="wp-block-table">
<table>
<tbody>
<tr /></tbody>
</table>
<th>Switch</th>
<th>Action</th>
<tr>
<td>-c</td>
<td>Keeps files after placing into the archive</td>
</tr>
<tr>
<td>-l</td>
<td>Get statistics for the compressed archive</td>
</tr>
<tr>
<td>-r</td>
<td>Recursively compresses files in the directories</td>
</tr>
<tr>
<td>-1 thru 9</td>
<td>Specifies the compression level on a scale of 1 thru 9</td>
</tr>
</figure>
<p><!-- /wp:table --></p>
<p><!-- wp:paragraph --></p>
<p><em>gzip</em> more or less works on a file-by-file basis and not on an archive basis like some Windows O/S zip utilities. The main reason for this is that <em>tar</em> already provides advanced archiving features. <em>gzip</em> is designed to provide only a compression mechanism.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Hence, when thinking of <em>gzip</em>, think of a single file. When thinking of multiple files, think of <em>tar</em> archives. Let's now explore this with our previous <em>tar</em> archive.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note</strong> − Seasoned Linux professionals will often refer to a tarred archive as a tarball.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Let's make another <em>tar</em> archive from our <em>rsync</em> backup.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# tar -cvf RemoteStuff.tar ./RemoteStuff/
[root@centos Documents]# ls
RemoteStuff.tar RemoteStuff/
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>For demonstration purposes, let's <em>gzip</em> the newly created tarball, and tell <em>gzip</em> to keep the old file. By default, without the <em>-c</em> option, gzip will replace the entire tar archive with a <em>.gz</em> file.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# gzip -c RemoteStuff.tar &gt; RemoteStuff.tar.gz
[root@centos Documents]# ls
RemoteStuff  RemoteStuff.tar  RemoteStuff.tar.gz
We now have our original directory, our tarred directory and finally our gziped tarball.
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Let's try to test the <em>-l</em> switch with <em>gzip</em>.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# gzip -l RemoteStuff.tar.gz  
[root@centos Documents]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>To demonstrate how <em>gzip</em> differs from Windows Zip Utilities, let's run gzip on a folder of text files.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# ls text_files/
 file1.txt  file2.txt  file3.txt  file4.txt  file5.txt
[root@centos Documents]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Now let's use the -r option to recursively compress all the text files in the directory.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# gzip -9 -r text_files/

[root@centos Documents]# ls ./text_files/
file1.txt.gz  file2.txt.gz  file3.txt.gz  file4.txt.gz  file5.txt.gz
 
[root@centos Documents]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>See? Not what some may have anticipated. All the original text files were removed and each was compressed individually. Because of this behavior, it is best to think of <em>gzip</em> alone when needing to work in single files.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Working with <em>tarballs</em>, let's extract our <em>rsynced</em> tarball into a new directory.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# tar -C /tmp -zxvf RemoteStuff.tar.gz
./RemoteStuff/
./RemoteStuff/.DS_Store
./RemoteStuff/DDWRT/
./RemoteStuff/DDWRT/.DS_Store
./RemoteStuff/DDWRT/ddwrt-linksys-wrt1200acv2-webflash.bin
./RemoteStuff/DDWRT/ddwrt_mod_notes.docx
./RemoteStuff/DDWRT/factory-to-ddwrt.bin
./RemoteStuff/open_ldap_config_notes/
./RemoteStuff/open_ldap_config_notes/ldap_directory_a.png
./RemoteStuff/open_ldap_config_notes/open_ldap_notes.txt
./RemoteStuff/perl_scripts/
./RemoteStuff/perl_scripts/mysnmp.pl
./RemoteStuff/php_scripts/
./RemoteStuff/php_scripts/chunked.php
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>As seen above, we extracted and decompressed our tarball into the /tmp directory.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# ls /tmp 
hsperfdata_root
RemoteStuff
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:heading --></p>
<h2>Encrypt TarBall Archives</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>Encrypting tarball archives for storing secure documents that may need to be accessed by other employees of the organization, in case of disaster recovery, can be a tricky concept. There are basically three ways to do this: either use GnuPG, or use openssl, or use a third part utility.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>GnuPG is primarily designed for asymmetric encryption and has an identity-association in mind rather than a passphrase. True, it can be used with symmetrical encryption, but this is not the main strength of GnuPG. Thus, I would discount GnuPG for storing archives with physical security when more people than the original person may need access (like maybe a corporate manager who wants to protect against an Administrator holding all the keys to the kingdom as leverage).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Openssl like GnuPG can do what we want and ships with CentOS. But again, is not specifically designed to do what we want and encryption has been questioned in the security community.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Our choice is a utility called <strong>7zip</strong>. 7zip is a compression utility like <em>gzip</em> but with many more features. Like Gnu Gzip, 7zip and its standards are in the open-source community. We just need to install 7zip from our EHEL Repository (the next chapter will cover installing the Extended Enterprise Repositories in detail).</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading {"level":3} --></p>
<h3>Install 7zip on Centos</h3>
<p><!-- /wp:heading --></p>
<p><!-- wp:paragraph --></p>
<p>7zip is a simple install once our EHEL repositories have been loaded and configured in CentOS.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# yum -y install p7zip.x86_64 p7zip-plugins.x86_64
Loaded plugins: fastestmirror, langpacks
base
| 3.6 kB  00:00:00
epel/x86_64/metalink
|  13 kB  00:00:00
epel
| 4.3 kB  00:00:00
extras
| 3.4 kB  00:00:00
updates
| 3.4 kB  00:00:00
(1/2): epel/x86_64/updateinfo
| 756 kB  00:00:04      
(2/2):
epel/x86_64/primary_db
| 4.6 MB  00:00:18
Loading mirror speeds from cached hostfile
--&gt; Running transaction check
---&gt; Package p7zip.x86_64 0:16.02-2.el7 will be installed
---&gt; Package p7zip-plugins.x86_64 0:16.02-2.el7 will be installed
--&gt; Finished Dependency Resolution
Dependencies Resolved
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Simple as that, 7zip is installed and ready be used with 256-bit AES encryption for our tarball archives.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>Now let's use 7z to encrypt our gzipped archive with a password. The syntax for doing so is pretty simple −</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">7z a -p &lt;output filename&gt;&lt;input filename&gt;
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Where, <strong>a:</strong> add to archive, and <strong>-p:</strong> encrypt and prompt for passphrase</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:preformatted --></p>
<pre class="wp-block-preformatted">[root@centos Documents]# 7z a -p RemoteStuff.tgz.7z RemoteStuff.tar.gz

7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21
p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,1 CPU Intel(R)
Core(TM) i5-4278U CPU @ 2.60GHz (40651),ASM,AES-NI)
Scanning the drive:
1 file, 2317140467 bytes (2210 MiB)

Creating archive: RemoteStuff.tgz.7z

Items to compress: 1

Enter password (will not be echoed):
Verify password (will not be echoed) :

Files read from disk: 1
Archive size: 2280453410 bytes (2175 MiB)
Everything is Ok
[root@centos Documents]# ls
RemoteStuff  RemoteStuff.tar  RemoteStuff.tar.gz  RemoteStuff.tgz.7z  slapD
text_files

[root@centos Documents]#
</pre>
<p><!-- /wp:preformatted --></p>
<p><!-- wp:paragraph --></p>
<p>Now, we have our .7z archive that encrypts the gzipped tarball with 256-bit AES.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><strong>Note</strong> − 7zip uses AES 256-bit encryption with an SHA-256 hash of the password and counter, repeated up to 512K times for key derivation. This should be secure enough if a complex key is used.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>The process of encrypting and recompressing the archive further can take some time with larger archives.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p>7zip is an advanced offering with more features than gzip or bzip2. However, it is not as standard with CentOS or amongst the Linux world. Thus, the other utilities should be used often as possible.</p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:paragraph --></p>
<p><!-- /wp:paragraph --></p>
<p><!-- wp:heading --></p>
<h2>Tham khảo</h2>
<p><!-- /wp:heading --></p>
<p><!-- wp:list --></p>
<ul>
<li>English version: <a href="https://www.tutorialspoint.com/linux_admin/linux_admin_backup_and_recovery.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/linux_admin/linux_admin_backup_and_recovery.htm </a></li>
</ul>
<p><!-- /wp:list --></p>
